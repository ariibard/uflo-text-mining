---
format:
  revealjs:
    echo: true
    theme: custom.scss
embed-resources: true
---

# Expresiones regulares (`regex`)

## Qu칠 es una expresi칩n regular?

::: r-stack
Son patrones utilizados para encontrar coincidencias dentro de 游늼
:::

## 쯇ara qu칠 se utilizan?

::: incremental
-   B칰squeda avanzada en texto libre

-   Validaci칩n de formularios

-   Extracci칩n de datos de grandes vol칰menes de texto.

-   Sustituci칩n de patrones en textos masivos.
:::

## 쯈u칠 es una expresi칩n regular?

```{r echo = TRUE}
#| code-line-numbers: 5
library(stringr)
library(tidyverse)
#style_mono_quarto(path_scss = "custom.scss")
texto <- "Hola mundo, hola universo"
patron <- "mundo"

# Detecta si el patr칩n est치 presente en el texto
str_detect(texto, patron)
```

## Librer칤a a utilizar

::::: columns
::: {.column width="30%"}
![](imagenes/1_string.png){fig-align="center"}
:::

::: {.column width="70%"}
<br> El paquete `stringr` proporciona un conjunto de funciones dise침adas para que trabajar con cadenas de texto
:::
:::::

## Funciones `stringr` : coincidencia

::: incremental
-   `str_detect(texto, patron)`: Detecta si un patr칩n est치 presente en una cadena (devuelve `TRUE/FALSE`).

-   `str_which(texto, patron)`: Devuelve los 칤ndices de las cadenas que coinciden con un patr칩n.

-   `str_count(texto, patron)`: Cuenta cu치ntas veces aparece un patr칩n en cada cadena.
:::

## Funciones `stringr` : coincidencia

::: incremental
-   `str_subset(texto, patron)`: Filtra las cadenas que contienen un patr칩n.

-   `str_match(texto, patron)`: Extrae las coincidencias del patr칩n con grupos de captura.

-   `str_extract(texto, patronn)`: Extrae la primera coincidencia del patr칩n.

-   `str_extract_all(texto, patron)`: Extrae **todas** las coincidencias del patr칩n
:::

## Funciones `stringr` : reemplazo y divisi칩n

::: incremental
-   `str_replace(texto, patron, reemplazo)`: Reemplaza la primera coincidencia del patr칩n por otro texto.

-   `tr_replace_all(texto, patron, reemplazo)`: Reemplaza todas las coincidencias del patr칩n.

-   `str_split(string, pattern):` Divide la cadena en partes basadas en un patr칩n.
:::

# 쮺칩mo armar expresiones regulares?

## Mi primera `regex`

Vamos a imaginar que tenemos un excel con las **anotaciones de las sesiones de terapia de un m칠dico**, y en base a ese campo de "notas" tenemos que traernos aquellos **registros** que tienen determinadas caracter칤sticas

## Armando expresiones regulares

La columna `id` tiene el identificador de historia clinica del paciente y `notas` las anotaciones del profesional

```{r}
notas_sesiones <- tibble::tibble(id = 1:13,
                        nota = c("ausente", "ausente al turno", "tuvo un papa ausente", "no concurri칩 al turno", "su mam치 estaba ausente", "no vino al turno su mama", "no vino turno", "mi hermana estaba ausente een casa","La ausencia de luz fue larga.", "se hizo un pap", "hermano concurre al turno", "DNI: 12345678", "ultima consulta en 2005"))

head(notas_sesiones)
```

## Observamos la base

```{r}
DT::datatable(notas_sesiones)
```

## Expresi칩n regular: `ausentes`

Me gustar칤a traerme todos los id de los pacientes que estuvieron ausentes a su sesi칩n

俱뫮잺 *con poner solo **ausente** no alcanza*

```{r}

patron <- regex("ausente",T)

notas_sesiones |>
  filter(str_detect(nota, patron))

```

## Inicio de la expresi칩n

`^` indica que la expresi칩n a buscar debe estar al **inicio** del vector o fila `|` es un "o"

```{r}

patron <- regex("^ausente",T)

notas_sesiones |>
  filter(str_detect(nota, patron))

```

## Caracteres l칩gicos

`|` es un "o" l칩gico en regex\
`()` **Agrupa expresiones** para combinarlas con `|` u otros operadores

```{r}

patron <- regex("^ausente|no (concurre|asiste|vino) al turno",T)

notas_sesiones |>
  filter(str_detect(nota, patron))

```

## ????

`?` hace que lo que le siga sea opcional

```{r}

patron <- regex("^ausente|no (concurre|asiste|vino) ?al turno",T)

notas_sesiones |>
  filter(str_detect(nota, patron))

```

## Borde de palabra

`\\b` limite de palabra *boundary*

```{r}

patron <- regex("^ausente|\\bno (concurre|asiste|vino) ?al turno",T)

notas_sesiones |>
  filter(str_detect(nota, patron))

```

## el punto

`.` indica que podria ser cualquier caracter

**Ejemplo**: Si quiero traerme todas las notas que digan `mam치`

```{r}

patron <- regex("mam치|pap치",T)

notas_sesiones |>
  filter(str_detect(nota, patron))

```

## el punto

`.` indica que podria ser cualquier caracter

**Ejemplo**: Si quiero traerme todas las notas que digan `mam치`

```{r}

patron <- regex("\\bmam.\\b|\\bpap.\\b",T)

notas_sesiones |>
  filter(str_detect(nota, patron))

```

## Cantidad de repeticiones o catacteres

`{n}` exactamente n repeticiones.

`{n,}` al menos n repeticiones.

`{n,m}` entre n y m repeticiones.

```{r}
patron <- regex("e{2,3}", TRUE) 
notas_sesiones |>
  filter(str_detect(nota, patron))
```

## Cantidad de repeticiones o catacteres

Si se le pone un . antes, busca cercan칤a entre tantos caracteres

**Ejemplo**: Busco mam치 o pap치 que se encuentren cerca de "ausente"

```{r}
patron <- regex("(\\bmam.\\b|\\bpap.\\b).{0,15}ausent", TRUE) 
notas_sesiones |>
  filter(str_detect(nota, patron))
```

## Clases de caracteres

`[aeiou]` busca cualquier vocal.

`[0-9]` busca cualquier n칰mero.

`[^aeiou]` busca cualquier letra que no sea vocal.

```{r}
patron <- regex("[0-9]", TRUE) 
notas_sesiones |>
  filter(str_detect(nota, patron))
```

## Clases de caracteres

`\\d` busca n칰meros.

`\\D` busca letras o s칤mbolos.

```{r}
patron <- regex("\\d{8}", TRUE) #busco solo 8 digitos
notas_sesiones |>
  filter(str_detect(nota, patron))

```

## Espacios

`\\s+` encuentra uno o m치s espacios.

`\\S+` encuentra palabras sin espacios.

```{r}
patron <- regex("\\s", TRUE)  # Encuentra espacios

frases <- tibble(nota = c("sinespacio", "con  espacios"))

frases |>
  filter(str_detect(nota, patron))
```

## Recursos

-   [cheatsheet](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf) con las funciones de stringr

-   m치s [caracteres](https://cheatography.com/davechild/cheat-sheets/regular-expressions/) para armado de expresiones regulares
